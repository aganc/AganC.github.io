---
layout:     post
title:      "继承和多态"
date:       2018-8-1 
header-img: "img/post-bg-1.png"
categories: Cpp
---

------

------

### 继承

c++中继承主要有三种关系：public,protected,private;他们的关系如下图所示：

![](\img\Blog\继承和多态\t1.jpg)

重点如下：

1.派生类内不管是public,protected,private继承，总是可以访问基类中的public,protected成员，基类中的private成员永远不能在派生类内直接访问，不论通过哪种方式。

2.派生类对象仅当public派生时，对基类中的public成员有可访问/可修改的权限，其他的都为不可访问/不可修改。

------

### 多态

多态：同一操作作用于不同的对象，可以有不同的解释，会产生不同的执行结果。

- 编译时多态性（静态多态性）：同一对象收到相同的消息却产生不同的函数调用，一般通过**函数重载**来实现，在编译时就实现了绑定，属于静态绑定。

**函数重载**：则是允许有多个同名的函数，而这些函数的参数列表不同，允许参数个数不同，参数类型不同，或者两者都不同。编译器会根据这些函数的不同列表，将同名的函数的名称做修饰，从而生成一些不同名称的预处理函数，来实现同名函数调用时的重载问题。

```c++
int Add(int left, int right)
{
    return left + right;
}
double Add(double left, int right)
{
    return left + right;
}

int main()
{
    Add(10, 20);
    Add(10.0,20);  //正常代码
    return 0;
}
```

静态多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数可以调用就调，没有的话就会发出警告或者报错。。。

![](\img\Blog\继承和多态\t2.jpg)

- 运行时多态性（动态多态性）：不同对象在收到相同消息时产生不同的动作，一般通过**虚函数**来实现，只有在运行时才能实现绑定，属于动态绑定。

动态多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。

```c++
 1 #include<iostream>
 2 using namespace std;
 3 
 4 class A
 5 {
 6 public:
 7     void foo()
 8     {
 9         printf("1\n");
10     }
11     virtual void fun()
12     {
13         printf("2\n");
14     }
15 };
16 class B : public A
17 {
18 public:
19     void foo()
20     {
21         printf("3\n");
22     }
23     void fun()
24     {
25         printf("4\n");
26     }
27 };
28 int main(void)
29 {
30     A a;
31     B b;
32     A *p = &a;
33     p->foo();
34     p->fun();
35     p = &b;
36     p->foo();
37     p->fun();
38     return 0;
39 }
```

第一个p->foo()和p->fuu()都很好理解，本身是基类指针，指向的又是基类对象，调用的都是基类本身的函数，因此输出结果就是1、2。
 　  第二个输出结果就是1、4。p->foo()和p->fuu()则是基类指针指向子类对象，正式体现多态的用法，p->foo()由于指针是个基类指针，指向是一个固定偏移量的函数，因此此时指向的就只能是基类的foo()函数的代码了，因此输出的结果还是1。而p->fun()指针是基类指针，指向的fun是一个虚函数，由于每个虚函数都有一个虚函数列表，此时p调用fun()并不是直接调用函数，而是通过虚函数列表找到相应的函数的地址，因此根据指向的对象不同，函数地址也将不同，这里将找到对应的子类的fun()函数的地址，因此输出的结果也会是子类的结果4。

小结：1.有virtual才可能发生多态现象

​	    2.不发生多态（无virtual）调用就按原类型调用

**总结一道面试题：**哪些函数不能定义为虚函数？ 
经检验下面的几个函数都不能定义为虚函数： 
1）友元函数，它不是类的成员函数 
2）全局函数 
3）静态成员函数，它没有this指针 
3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

### 纯虚函数

纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加“=0”。

引入原因
   1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 
   2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 
  为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为**抽象类**，它不能生成对象，即抽象基类不能被实例化。这样就很好地解决了上述两个问题。

小结：

1）虚函数和纯虚函数的区别：

1.虚函数是实现的，他的作用是为了能让这个函数在它的子类里可以被覆盖，以达到多态的目的。纯虚函数只是一个接口，是个函数声明而已，他要留到子类里去实现。

2.虚函数在子类里也可以不重载，但纯虚函数必须在子类里实现。

3.虚函数类似于实作继承，继承接口的同时也继承了父类的实现。纯虚函数类似于介面继承，即只关注接口的统一性，实现由子类完成。

4.带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承。

2）简述C++中重载、重写（覆盖）和隐藏 
（1）重载：重载从overload翻译过来，**是指同一可访问区内被声明的几个具有不同参数列**（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。 
（2）隐藏：**隐藏是指派生类的函数屏蔽了与其同名的基类函数**。注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。 
（3）重写：重写翻译自override，也翻译成覆盖（更好一点），是**指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同**（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。 



------

### 后记

不定期更新，不定期放鸽！哈哈哈😄
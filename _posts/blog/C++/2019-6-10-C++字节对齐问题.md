---
layout:     post
title:      "C++字节对齐"
date:       2019-6-12 
header-img: "img/post-bg-1.png"
categories: Cpp
tags: C++基础知识
---

------

#### 基本数据类型大小

![](\img\Blog\字节对齐\t5.png)

#### 对齐原则：

原则1：数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。
原则2：结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
原则3：结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。

#### 默认对齐值：

Linux 默认#pragma pack(4)

window 默认#pragma pack(8)

注：可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。

例1：

```c++
#pragma pack(1)
struct AA {
    int a;   //长度4 > 1 按1对齐；偏移量为0；
    char b;  //长度1 = 1 按1对齐；偏移量为4
    short c; //长度2 > 1 按1对齐；偏移量为5；
    char d;  //长度1 = 1 按1对齐；偏移量为6；
    //整体存放在[0~7]位置区间中，共八个字节。
};
```

整体对齐系数 = min((max(int,short,char), 1) = 1，所以不需要再进行整体对齐。整体大小就为8。

![](\img\Blog\字节对齐\t1.png)

例2

```c++
#pragma pack(2)
struct AA {
    int a;   //长度4 > 2 按2对齐；偏移量为0；
    char b;  //长度1 < 2 按1对齐；偏移量为4；
    short c; //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；
    char d;  //长度1 < 2 按1对齐；偏移量为7；
};
```

整体对齐系数 = min((max(int,short,char), 2) = 2，将9提升到2的倍数，则为10.所以最终结果为10个字节。

![](\img\Blog\字节对齐\t2.png)

例3

```c++
#pragma pack(4)
struct AA {
    int a;   //长度4 = 4 按4对齐；偏移量为0；
    char b;  //长度1 < 4 按1对齐；偏移量为4；
    short c; //长度2 < 4 按2对齐；偏移量要提升到2的倍数6；
    char d;  //长度1 < 4 按1对齐；偏移量为7；
};
```

整体对齐系数 = min((max(int,short,char), 4) = 4，将9提升到4的倍数，则为12.所以最终结果为12个字节。

![](\img\Blog\字节对齐\t3.png)

例4

```c++
#pragma pack(8)
struct AA {
    int a;   //长度4 < 8 按4对齐；偏移量为0；
    char b;  //长度1 < 8 按1对齐；偏移量为4；
    short c; //长度2 < 8 按2对齐；偏移量要提升到2的倍数6；
    char d;  //长度1 < 8 按1对齐；偏移量为7；
};
```

整体对齐系数 = min((max(int,short,char), 8) = 4，将9提升到4的倍数，则为12.所以最终结果为12个字节。

**小结：当#pragma pack的n值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。**

例5

```c++
struct EE
{
    int a;      //长度4 < 8 按4对齐；偏移量为0；
    char b;     //长度1 < 8 按1对齐；偏移量为4；
    short c;    //长度2 < 8 按2对齐；偏移量由5提升到6；
    //结构体内部最大元素为int,由于偏移量为8刚好是4的整数倍，所以从8开始存放接下来的struct FF
    struct FF
    {
        int a1;     //长度4 < 8 按4对齐；偏移量为8；
        char b1;    //长度1 < 8 按1对齐；偏移量为12；
        short c1;   //长度2 < 8 按2对齐；偏移量为13,提升到2的倍数14；
        char d1;    //长度1 < 8 按1对齐；偏移量为16；
    };
    //整体对齐系数 = min((max(int,short,char), 8) = 4，将内存大小由17补齐到4的整数倍20
    char d;         //长度1 < 8 按1对齐；偏移量为21；
    //整体对齐系数 = min((max(int,short,char), 8) = 4，将内存大小由21补齐到4的整数倍24
};
```

![](\img\Blog\字节对齐\t4.png)

#### 类的sizeof()

1.静态变量的存放位置与结构体实例的存储地址无关，是单独存放在静态数据区的，因此用siezof计算其大小时没有将静态成员所占的空间计算进来。

2.空类是会占用内存空间的，而且大小是1，原因是C++要求每个实例在内存中都有独一无二的地址。

（一）类内部的成员变量：

普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。
static修饰的静态变量：不占用内容，原因是编译器将其放在全局变量区。
（二）类内部的成员函数：

普通函数：不占用内存。
虚函数：要占用4个字节，用来指定虚函数的虚拟函数表的入口地址。所以一个类的虚函数所占用的地址是不变的，和虚函数的个数是没有关系的

例6

```c++
#pragma pack(4)
class CBase2
{
private:
	char c;
	short sh;
	int a;
public:
	virtual void fOut(){ cout << "hello" << endl; }
};
```

包含虚函数时，类中需要保存虚函数表的入口地址指针，即需要多保存一个指针。这个值跟虚函数的个数多少没有关系。sizeof(CBase2)=12

例7

```c++
#pragma pack(4)
class CBase2
{
private:
	char c;
	short sh;
	int a;
public:
	virtual void fOut(){ cout << "virtual 1" << endl; }
};
class cDerive :public CBase
{
private :
	int n;
public:
	virtual void fPut(){ cout << "virtual 2"; }
};
```

子类所占内存大小是**父类+自身成员变量的值。**特别注意的是，子类与父类共享同一个虚函数指针，因此当子类新声明一个虚函数时，不必在对其保存虚函数表指针入口。

sizeof(cDerive)= sizeof(cBase)+sizeof(int n) = 16

#### 联合体的sizeof()

联合体的大小取决于它所有的成员中占用空间最大的一个成员的大小。

```
union u
{
    char a[13];
    int p;
};
```

sizeof(u)=16   考虑字节对齐问题！

#### 系统要对于结构体数据进行内存对齐？

1、平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2、性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
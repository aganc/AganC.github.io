---
layout:     post
title:      "计算机web"
date:       2018-10-12 
header-img: "img/post-bg-1.png"
categories: Cpp，网络基础知识
---

### 计算机网络体系结构：

![](\img\Blog\cw\t1.png)

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。
- **传输层** ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。
- **网络层** ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。
- **数据链路层** ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

###  I/O 模型：

一个输入操作通常包括两个阶段：

- 等待数据准备好
- 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

Unix 有五种 I/O 模型：

- 阻塞式 I/O

- 非阻塞式 I/O

- I/O 复用（select 和 poll）

- 信号驱动式 I/O（SIGIO）

- 异步 I/O（AIO

  [IO模型链接：]: https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF

  ------

  

### UDP和TCP的区别：

1.用户数据报协议UDP（User Datagram Protocal）：无连接，经最大可能交付，可以多对多的交互通信，面向报文（对应用层传下来的报文不拆分，不合并，只添加UDP首部），由于UDP可以提高传输效率，所以UDP被广泛应用于数据量大且精确性要求不高的数据传输，比如我们平常在网站上观看视频或者听音乐的时候应用的基本上都是UDP传输协议。

2.传输控制协议TCP（Transmission Control Protocol）：面向连接的，提供可靠传输，每一条TCP连接只能是点对点的，属于全双工通信，面向字节流（把报文当成字节流，组织成大小不一的数据块），TCP传输速度较快，适用于传大量的数据。在实际的使用中，TCP主要应用于文件传输精确性相对要求较高且不是很紧急的情景，比如电子邮件、远程登录等。有时在这些应用场景下即使丢失一两个字节也会造成不可挽回的错误，所以这些场景中一般都使用TCP传输协议。

### TCP首部格式

**序号（seq）**：对传输的字节流进行编号，例如序号是100，表示报文段是从字节流的第100个位置开始

**确认号（ack）**：希望收到下一个报文段的序号，例如：A给Ｂ发送了一个报文段，报文段的序号是300，报文段长度是200。Ｂ则希望Ａ下一个报文段是501，ack=seq+1.

**确认 ACK** ：当 ACK=1 时**确认号字段有效**，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1

**同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 **表示连接请求**。SYN=1，ACK=1表示**同意建立连接**

**终止 FIN** ：释放一个连接，当 FIN=1 时，表示**发送方的数据已发送完**，并要求释放连接。

### TCP三次握手

**目的**：连接服务器指定的端口，建立TCP连接，并同步连接双方的序列号和确认号并交换TCP窗口大小信息。

A为客户端，B为服务器

- 首先B处于LISTEN监听状态，等待客户端A的连接请求

- A向B发送连接请求，SYN=1，ACK=0，seq=x初始化序号x

- B接受到连接请求后；向A发送SYN=1，表示同意建立连接；ACK=1,序号seq=y，确认号ack=x+1

- A收到B的连接确认后，发送ACK=1，seq=x+1，ack=y+1

- B收到A的连接确认后，建立连接

  ![](\img\Blog\cw\t2.png)

**三次握手的原因**

为了防止失效的连接请求到达服务器后，让服务器打开不必要的连接，浪费服务器资源。

客户端发送的连接请求如果在网络中滞留，长时间没收到服务器的响应。客户端会重新发送连接请求，服务器回应连接请求，如果不进行三次握手，滞留的连接请求到达服务器后，会建立两个连接。如果有三次握手客户端会忽略服务器对滞留的连接确认。

### TCP四次挥手

目的：由于TCP是全双工连接，因此每个方向都必须单独进行关闭。

A是主动关闭方，B是被动响应方。

- A发送**连接释放**的报文，FIN=1

- B收到A的连接释放后，给A发出**连接释放确认**，但B还可以向A发送数据，确保数据已发送完

- 当B不再需要连接后，给A发送连接释放，FIN=1

- A 收到后B的连接释放后，给B发出连接释放确认，进入TIME-WAIT状态，等待 2 MSL（最大报文存活时间）后释放连接

- B 收到 A 的确认后释放连接

  ![](\img\Blog\cw\t3.png)

**四次挥手的原因**

客户端发送连接释放之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器才会发送连接释放。

客户端接收到服务器端的 FIN 报文后进入TIME_WAIT，等待时间 2MSL。

- 为了确保确认报文服务器B能收到。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 为了让本连接持续期内所产生的所有报文都从网络中消失